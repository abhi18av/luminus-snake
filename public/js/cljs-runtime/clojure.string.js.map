{"version":3,"file":"clojure.string.js","sources":["clojure/string.cljs"],"mappings":"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","names":["clojure.string/starts-with?","s","substr","match","clojure.string/replace-all","replacement","ch","c","cljs.core/cons","cljs.core/str","cljs.core/vec","cljs.core.subvec.cljs$core$IFn$_invoke$arity$3","cljs.core/seq","cljs.core.subs.cljs$core$IFn$_invoke$arity$2","cljs.core.conj.cljs$core$IFn$_invoke$arity$2","cljs.core.map.cljs$core$IFn$_invoke$arity$2","result","limit","parts","index","clojure.string/capitalize","clojure.string/trim-newline","clojure.string/pop-last-while-empty","v","clojure.string/reverse","clojure.string/trimr","re","coll","value","from-index","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","cljs.core/count","matches","cljs.core.get.cljs$core$IFn$_invoke$arity$2","buffer","sb","cmap","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","cljs.core/conj","clojure.string/replace-first","var_args","G__26724","clojure.string/join","js/Error","G__26673","clojure.string/split-with-empty-regex","goog.string/trimRight","m","cljs.core/re-find","clojure.string.split.cljs$core$IFn$_invoke$arity$2","goog.string/isEmptySafe","goog/string.StringBuffer","G__26696","f","cljs.core/first","clojure.string/discard-trailing-if-needed","clojure.string/blank?","goog.string/startsWith","r","clojure.string/seq-reverse","G__26818","clojure.string/index-of","G__26697","clojure.string/trim","clojure.string/upper-case","length","cljs.core/PersistentVector","clojure.string/replace","js/RegExp","clojure.string/ends-with?","goog.string/trim","clojure.string/includes?","clojure.string.split.cljs$core$IFn$_invoke$arity$3","G__26832","clojure.string/last-index-of","G__26788","clojure.string/split","cljs.core/peek","clojure.string/escape","clojure.string/re-surrogate-pair","goog.string/regExpEscape","separator","clojure.string/replace-with","clojure.string/triml","cljs.core/next","goog.string/endsWith","goog.string/capitalize","clojure.string/lower-case","goog.string/trimLeft","goog.string/contains","cljs.core.drop_last.cljs$core$IFn$_invoke$arity$2","args","pred__26766","expr__26767","cljs.core/==","cljs.core/pop","clojure.string/split-lines"],"sourcesContent":[";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns clojure.string\n  (:refer-clojure :exclude [replace reverse])\n  (:require [goog.string :as gstring])\n  (:import [goog.string StringBuffer]))\n\n(defn- seq-reverse\n  [coll]\n  (reduce conj () coll))\n\n(def ^:private re-surrogate-pair\n  (js/RegExp. \"([\\\\uD800-\\\\uDBFF])([\\\\uDC00-\\\\uDFFF])\" \"g\"))\n\n(defn reverse\n  \"Returns s with its characters reversed.\"\n  [s]\n  (-> (.replace s re-surrogate-pair \"$2$1\")\n      (.. (split \"\") (reverse) (join \"\"))))\n\n(defn- replace-all\n  [s re replacement]\n  (let [r (js/RegExp. (.-source re)\n                      (cond-> \"g\"\n                        (.-ignoreCase re) (str \"i\")\n                        (.-multiline re) (str \"m\")\n                        (.-unicode re) (str \"u\")))]\n    (.replace s r replacement)))\n\n(defn- replace-with\n  [f]\n  (fn [& args]\n    (let [matches (drop-last 2 args)]\n      (if (= (count matches) 1)\n        (f (first matches))\n        (f (vec matches))))))\n\n(defn replace\n  \"Replaces all instance of match with replacement in s.\n\n   match/replacement can be:\n\n   string / string\n   pattern / (string or function of match).\n\n   See also replace-first.\n\n   The replacement is literal (i.e. none of its characters are treated\n   specially) for all cases above except pattern / string.\n\n   For pattern / string, $1, $2, etc. in the replacement string are\n   substituted with the string that matched the corresponding\n   parenthesized group in the pattern.\n\n   Example:\n   (clojure.string/replace \\\"Almost Pig Latin\\\" #\\\"\\\\b(\\\\w)(\\\\w+)\\\\b\\\" \\\"$2$1ay\\\")\n   -> \\\"lmostAay igPay atinLay\\\"\"\n  [s match replacement]\n  (cond\n    (string? match)\n    (.replace s (js/RegExp. (gstring/regExpEscape match) \"g\") replacement)\n\n    (instance? js/RegExp match)\n    (if (string? replacement)\n      (replace-all s match replacement)\n      (replace-all s match (replace-with replacement)))\n\n    :else (throw (str \"Invalid match arg: \" match))))\n\n(defn replace-first\n  \"Replaces the first instance of match with replacement in s.\n\n   match/replacement can be:\n\n   string / string\n   pattern / (string or function of match).\n\n   See also replace.\n\n   The replacement is literal (i.e. none of its characters are treated\n   specially) for all cases above except pattern / string.\n\n   For pattern / string, $1, $2, etc. in the replacement string are\n   substituted with the string that matched the corresponding\n   parenthesized group in the pattern.\n\n   Example:\n   (clojure.string/replace-first \\\"swap first two words\\\"\n                                 #\\\"(\\\\w+)(\\\\s+)(\\\\w+)\\\" \\\"$3$2$1\\\")\n   -> \\\"first swap two words\\\"\"\n  [s match replacement]\n  (.replace s match replacement))\n\n(defn join\n  \"Returns a string of all elements in coll, as returned by (seq coll),\n  separated by an optional separator.\"\n  ([coll]\n   (loop [sb (StringBuffer.) coll (seq coll)]\n     (if-not (nil? coll)\n       (recur (. sb (append (str (first coll)))) (next coll))\n       (.toString sb))))\n  ([separator coll]\n   (loop [sb (StringBuffer.) coll (seq coll)]\n     (if-not (nil? coll)\n       (do\n         (. sb (append (str (first coll))))\n         (let [coll (next coll)]\n           (when-not (nil? coll)\n             (. sb (append separator)))\n           (recur sb coll)))\n       (.toString sb)))))\n\n(defn upper-case\n  \"Converts string to all upper-case.\"\n  [s]\n  (.toUpperCase s))\n\n(defn lower-case\n  \"Converts string to all lower-case.\"\n  [s]\n  (.toLowerCase s))\n\n(defn capitalize\n  \"Converts first character of the string to upper-case, all other\n  characters to lower-case.\"\n  [s]\n  (gstring/capitalize s))\n\n;; The JavaScript split function takes a limit argument but the return\n;; value is not the same as the Java split function.\n;;\n;; Java: (.split \"a-b-c\" #\"-\" 2) => [\"a\" \"b-c\"]\n;; JavaScript: (.split \"a-b-c\" #\"-\" 2) => [\"a\" \"b\"]\n;;\n;; For consistency, the three arg version has been implemented to\n;; mimic Java's behavior.\n\n(defn- pop-last-while-empty\n  [v]\n  (loop [v v]\n    (if (identical? \"\" (peek v))\n      (recur (pop v))\n      v)))\n\n(defn- discard-trailing-if-needed\n  [limit v]\n  (if (and (== 0 limit) (< 1 (count v)))\n    (pop-last-while-empty v)\n    v))\n\n(defn- split-with-empty-regex\n  [s limit]\n  (if (or (<= limit 0) (>= limit (+ 2 (count s))))\n    (conj (vec (cons \"\" (map str (seq s)))) \"\")\n    (condp == limit\n      1 (vector s)\n      2 (vector \"\" s)\n      (let [c (- limit 2)]\n        (conj (vec (cons \"\" (subvec (vec (map str (seq s))) 0 c))) (subs s c))))))\n\n(defn split\n  \"Splits string on a regular expression. Optional argument limit is\n  the maximum number of splits. Not lazy. Returns vector of the splits.\"\n  ([s re]\n     (split s re 0))\n    ([s re limit]\n     (discard-trailing-if-needed limit\n       (if (identical? \"/(?:)/\" (str re))\n         (split-with-empty-regex s limit)\n         (if (< limit 1)\n           (vec (.split (str s) re))\n           (loop [s s\n                  limit limit\n                  parts []]\n             (if (== 1 limit)\n               (conj parts s)\n               (let [m (re-find re s)]\n                 (if-not (nil? m)\n                   (let [index (.indexOf s m)]\n                     (recur (.substring s (+ index (count m)))\n                       (dec limit)\n                       (conj parts (.substring s 0 index))))\n                   (conj parts s))))))))))\n\n(defn split-lines\n  \"Splits s on \\\\n or \\\\r\\\\n.\"\n  [s]\n  (split s #\"\\n|\\r\\n\"))\n\n(defn trim\n  \"Removes whitespace from both ends of string.\"\n  [s]\n  (gstring/trim s))\n\n(defn triml\n  \"Removes whitespace from the left side of string.\"\n  [s]\n  (gstring/trimLeft s))\n\n(defn trimr\n  \"Removes whitespace from the right side of string.\"\n  [s]\n  (gstring/trimRight s))\n\n(defn trim-newline\n  \"Removes all trailing newline \\\\n or return \\\\r characters from\n  string.  Similar to Perl's chomp.\"\n  [s]\n  (loop [index (.-length s)]\n    (if (zero? index)\n      \"\"\n      (let [ch (get s (dec index))]\n        (if (or (identical? \\newline ch)\n                (identical? \\return ch))\n          (recur (dec index))\n          (.substring s 0 index))))))\n\n(defn ^boolean blank?\n  \"True is s is nil, empty, or contains only whitespace.\"\n  [s]\n  (gstring/isEmptySafe s))\n\n(defn escape\n  \"Return a new string, using cmap to escape each character ch\n   from s as follows:\n\n   If (cmap ch) is nil, append ch to the new string.\n   If (cmap ch) is non-nil, append (str (cmap ch)) instead.\"\n  [s cmap]\n  (let [buffer (StringBuffer.)\n        length (.-length s)]\n    (loop [index 0]\n      (if (== length index)\n        (. buffer (toString))\n        (let [ch (.charAt s index)\n              replacement (get cmap ch)]\n          (if-not (nil? replacement)\n            (.append buffer (str replacement))\n            (.append buffer ch))\n          (recur (inc index)))))))\n\n(defn index-of\n  \"Return index of value (string or char) in s, optionally searching\n  forward from from-index or nil if not found.\"\n  ([s value]\n   (let [result (.indexOf s value)]\n     (if (neg? result)\n       nil\n       result)))\n  ([s value from-index]\n   (let [result (.indexOf s value from-index)]\n     (if (neg? result)\n       nil\n       result))))\n\n(defn last-index-of\n  \"Return last index of value (string or char) in s, optionally\n  searching backward from from-index or nil if not found.\"\n  ([s value]\n   (let [result (.lastIndexOf s value)]\n     (if (neg? result)\n       nil\n       result)))\n  ([s value from-index]\n   (let [result (.lastIndexOf s value from-index)]\n     (if (neg? result)\n       nil\n       result))))\n\n(defn ^boolean starts-with?\n  \"True if s starts with substr.\"\n  [s substr]\n  (gstring/startsWith s substr))\n\n(defn ^boolean ends-with?\n  \"True if s ends with substr.\"\n  [s substr]\n  (gstring/endsWith s substr))\n\n(defn ^boolean includes?\n  \"True if s includes substr.\"\n  [s substr]\n  (gstring/contains s substr))\n"]}